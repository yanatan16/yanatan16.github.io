---
layout: post
categories: philosophy
title: Programming is Math
date: Tue Apr 15 2014 21:40:36 GMT-0600 (MDT)
redirect_from: /post/82860743939/

# Old tumblr stuff
id: 82860743939
link: http://joneisen.tumblr.com/post/82860743939/programming-is-math
slug: programming-is-math
publish: 2014-04-015
tags: math, programming, philosophy
---


I meet a lot of people who tell me they don’t like math, or they aren’t good at it. I also meet a lot of programmers. Many programmer’s mathematics backgrounds stop at basic calculus and an applied take on discrete math. There are many higher forms of mathematics, that are mostly reserved for those who give their lives away for 10 years in school to learn and study. But at its core, higher order math is in many ways *very similar* to programming.

Math is the study of problems in their most abstract forms. Take the common algebra equality: `y = 3x + 4`. It may represent many things, from the price of apples at a market as a function of demand, the speed of a car as it accelerates over time, or it may represent a child’s displeasure as a function of stupid common algebra busywork given to him or her. By abstracting problems to these forms, it allows us to see similarities between problems that take the same abstract form, even if they are radically different in real life. For instance, finding the rate of change of anything is solved the same mathematically, whether its the speed of a car or the expected price change in stocks.

I have a lot of issues with the way “math” is taught in (American) schools. Its basically a memorization of rules and patterns that a teacher requires be done over and over again. To be “good” at math in schools means being good at pattern recognition and spitting that out on command. It has almost nothing to do with performing well at higher math, which requires coming up with *new* ideas by coalescing facts together.

So I’ve talked about two primary things which are required of a good mathematician: abstraction and problem solving. Oddly (or not) enough, this is exactly what makes a good programmer. By creating frameworks and multi-purpose libraries, we are creating abstractions so multiple applications from differing fields can use the same tested code for their benefit. The problem solving skills required to solve proofs in math is very similar to solving a problem in programming, be it debugging, finding that exactly correct abstractions, or solving a distributed systems challenge.

Every time you program, your performing the same tasks a mathematician does, except your language is machine code, and mathematicians speak academia.

